# Getting Started Part II: Tour of Piwik Internals

## About this guide

In [Part I](/guides/getting-started-part-1) you set up your development environment and created a new plugin. In this guide, we'll make that plugin do something and in the process, you'll learn about different Piwik concepts.

This guide will show you:

- **how to define controllers to add new pages to Piwik**
- **how to define new reports and expose them through Piwik's [Reporting API](#)**
- **how to use JavaScript in a plugin**

**Guide Assumptions**

This guide assumes that you've completed [Part I](/guides/getting-started-part-1) of this guide.

## Make your plugin do something

For this guide we don't want to do anything really complicated, so we'll just define a new analytics report that uses realtime data and add a new page to Piwik that displays the report.

### Adding a new reporting page

First, let's add a new reporting page to Piwik. Links to Piwik's reporting pages are displayed on the main page under the logo:

<img src="/img/reporting_menu.png"/>

What gets put there is determined by plugins that add menu items through the [MenuMain](#) class.

#### Adding a controller method

To add a new page, we'll start by creating the page itself. In Piwik, HTML is generated and served by [Controller](#) methods, so we'll add a new method to your plugin's controller. Since the HTML generated by this method will be the main page for this plugin, we'll call the method **index**.

    class Controller extends \Piwik\Plugin\Controller
    {
        // the output of this method will be accessible via a URL like index.php?module=MyPlugin&action=index
        public function index()
        {

        }
    }

#### Using a View

Inside the Controller method we'll generate HTML by using a [View](#). View objects manage Twig templates; they define some basic properties, [filters](#) and [Twig functions](#) for templates to use, and allow you to set other template properties.

Right now, we don't have much to display, so we won't be setting any properties. In your controller method, add the following code:

    $view = new View("@MyPlugin/index.twig");
    return $view->render();

<div markdown="1" class="alert alert-warning">
**Template Naming Convention**

Our template will be named **index.twig** since the method it's in is named **index**. This is the naming convention used in Piwik. If a template doesn't correspond to a controller method, its name should describe what it outputs and be prefixed with an underscore (for example, **_dataTable.twig**).
</div>

#### Adding a Twig template

The **console** tool will automatically create a Now we'll create our Twig template. In the **templates** subdirectory of your plugin's root directory, add a file named **index.twig**. In the file, add the following code:

    <h1>Realtime Analytics</h1>

    <strong>Hello world!</strong>

If you open a browser and open the URL **http://localhost/index.php?module=MyPlugin&action=index&idSite=1&date=today&period=day** (remember to replace **MyPlugin** with the name of your plugin), you should see the page you just created!

<img src="/img/myplugin_index_noembed.png"/>

#### Adding a menu item

Now that there's a page, we need to add it to the reporting menu so users can get to it. The [MenuMain](#) class (and other menu managing classes) allows plugins to add menu items through an **event** named [Menu.Reporting.addItems](#).

<div markdown="1" class="alert alert-warning">
**About Events**

**Events** are one of the main ways Piwik allows plugins to add new functionality. At certain points during execution, Piwik will post an event to the **EventDispatcher**. Plugins can register callbacks with events so those callbacks will be invoked when events are posted.
</div>

Our plugin has to handle this event, so we'll associate a method with the event. In the **getListHooksRegistered** method of your plugin descriptor class (the class that extends [Piwik\Plugin](#) and has the same name as your plugin), add the following code:

    return array(
        'AssetManager.getJavaScriptFiles' => 'getJsFiles',
        'Menu.Reporting.addItems' => 'getReportingMenuItems'
    );

Then add this method to the class:

    public function getReportingMenuItems()
    {
        \Piwik\Menu\MenuMain::getInstance()->add(
            $category = 'General_Visitors', // this is a 'translation token'. it will be replaced by
                                            // a translated string based on the user's language preference.
                                            // read about internationalization below to learn more.
            $title = 'Real-time Reports',
            $urlParams = array('module' => $this->getPluginName(), 'action' => 'index')
        );
    }

Now, if you load Piwik in a browser, you'll see the menu item:

<img src="/img/myplugin_visitors_menu_item.png"/>

If you click on it, the page will be loaded below the period selector:

<img src="/img/myplugin_index_embed.png"/>

### Adding a new report

We've created a plugin and got it to display something in Piwik's UI. Now let's make it show something useful. We're going to create a new report that uses the realtime visit data returned by the [Live!](#) plugin and reports on the browsers used.

<div markdown="1" class="alert alert-warning">
**On reports and metrics**

Reports and metrics are the two types of analytics data Piwik calculates and stores. Metrics are just single values, like **visits**. Reports are two dimensional arrays of values, usually metric values and are stored using the [DataTable](#) class.
</div>

#### Adding an API method

Reports and metrics are all served through API class methods, so we'll add a new one for our report. In your plugin's API class (stored in **API.php**), add the following method:

    public function getLastVisitsByBrowser($idSite, $period, $date, $segment = false)
    {
        return array();
    }

<div markdown="1" class="alert alert-warning">
**Analytics Parameters**

Every API method that serves a report or metric will have the parameters listed above. This is because all analytics data describes data that is tracked for a certain website and during a certain period. A [segment](#) can be supplied to further reduce the data that is analyzed, but it is optional (which is why the parameter defaults to `false`).

The website is determined by the `$idSite` parameter and the period by both the `$period` and `$date` parameters. The segment is determined by the value in the `$segment` parameter.
</div>

You can see the output of this method if you visit this URL: **http://localhost/index.php?module=API&method=MyPlugin.getLastVisitsByBrowser&idSite=1&date=today&period=week**.

#### Implementing the API method

Our new report will use realtime visit data, so the first thing our API method must do is get it. We'll use the **Live.getLastVisitsDetails** method:

    public function getLastVisitsByBrowser($idSite, $period, $date, $segment = false)
    {
        $data = \Piwik\Plugins\Live\API::getInstance()->getLastVisitsDetails(
            $idSite,
            $period,
            $date,
            $segment,
            $numLastVisitorsToFetch = 100,
            $minTimestamp = false,
            $flat = false,
            $doNotFetchActions = true
        );
        $data->applyQueuedFilters();

        return array();
    }

This will return a [DataTable](#) instance that holds information for each visit in its rows.

<div markdown="1" class="alert alert-warning">
**About [DataTable](#)s**

As stated above [DataTable](#)s store report data. They are essentially just an array of rows, where each row is an array of columns.
</div>

Now that we've got a list of visits, we need to count the number of visits for each browser used. We'll do this by manually iterating through each row to create a new [DataTable](#) instance:

    public function getLastVisitsByBrowser($idSite, $period, $date, $segment = false)
    {
        $data = \Piwik\Plugins\Live\API::getInstance()->getLastVisitsDetails(
            $idSite,
            $period,
            $date,
            $segment,
            $numLastVisitorsToFetch = 100,
            $minTimestamp = false,
            $flat = false,
            $doNotFetchActions = true
        );

        $result = $data->getEmptyClone($keepFilters = false); // we could create a new instance by using new DataTable(),
                                                              // but that wouldn't copy DataTable metadata, which can be
                                                              // useful.

        foreach ($data->getRows() as $visitRow) {
            $browserName = $visitRow->getColumn('browserName');

            $resultRowForBrowser = $result->getRowFromLabel($browserName);

            // if there is no row for this browser, create it
            if ($resultRowForBrowser === false) {
                $result->addRowFromSimpleArray(array(
                    'label' => $browserName,
                    'nb_visits' => 1
                ));
            } else { // if there is a row, increment the visit count
                $resultRowForBrowser->setColumn('nb_visits', $resultRowForBrowser->getColumn('nb_visits') + 1);
            }
        }

        return $result;
    }

If you visit **http://localhost/index.php?module=API&method=MyPlugin.getLastVisitsByBrowser&idSite=1&date=today&period=week** you should see the new report!

<div markdown="1" class="alert alert-warning">
**Realtime Reports vs Archived Reports**

This new API method directly accesses visit data. That is because the report is a real-time report. Most reports aren't in real-time because the amount of time it would take to process the visits they report on would make the UI unusable. These reports are calculated and **cached** during the [Archiving Process](#). To learn more, read our [All About Analytics Data](#) guide.
</div>

### Displaying the report

Now that we've defined a new report, we need to display it. We'll do this by adding a new method to our controller:

    public function getLastVisitsByBrowser()
    {
        // ...
    }

We add a new method because we'll be using a special view class that will sometimes use AJAX to reload the report, so there has to be a way to get **just** the HTML for the display.

The special view class we'll use is called [ViewDataTable](#), and here's how we'll use it:

    public function getLastVisitsByBrowser()
    {
        // ViewDataTable instances are created by the Factory, not through the new operator
        $view = \Piwik\ViewDataTable\Factory::build(
            $defaultVisualization = 'table',
            $apiAction = 'MyPlugin.getLastVisitsByBrowser'
        );

        // after a ViewDataTable instance is created, it must be configured so the display is perfect
        // for the report. this is done by setting properties of the ViewDataTable::$config object.
        $view->config->show_table_all_columns = false;
        $view->config->show_goals = false;
        $view->config->translations['label'] = 'Browser';

        return $view->render();
    }

<div markdown="1" class="alert alert-warning">
**Report Visualizations**

The [ViewDataTable](#) class outputs what Piwik calls a **report visualization**. Report visualizations display an analytics report in some way. They can be in any format, including HTML or JavaScript (like the default **table** visualization or one of the graphs) or an image (like the **sparkline** visualization).

Plugins can create their own visualizations. To find out how, read our [Visualizing Report Data](#) guide (after your done with this guide, of course).
</div>

Now that we have a method that outputs a display for the report, we need to embed it in the plugin's main page. Change the `index()` controller method to look like this:

    public function index()
    {
        $view = new View("@MyPlugin/index.twig");
        $view->getLastVisitsByBrowserReport = $this->getLastVisitsByBrowser();
        echo $view->render();
    }

And change the **index.twig** template to look like this:

    <h1>Realtime Analytics</h1>

    {{ getLastVisitsByBrowserReport|raw }}

Now if you view the page in Piwik, you'll see something like this:

<img src="/img/myplugin_new_report_display.png"/>

### Updating the report in realtime

So now there's a page with a report that displays the browsers of the latest visitors. It uses realtime data, but it's not truly realtime since after a couple minutes, the report will be out of date. To make the report more realtime we'll add an option for the user to update the report.

We'll allow the user to update the report by clicking a link. Add the following to the bottom of your **index.twig** file:

    <a id="realtime-reports-reload" href="#">Reload</a>

#### Adding JavaScript files to Piwik

To make the report reload itself, we'll have to write some JavaScript code. This means we'll need a JavaScript file.

The `console` command line tool will automatically generate a JavaScript file called **plugin.js** which we'll use. If it didn't exist, though, we'd have to create a new file in the **javascripts** subdirectory and let Piwik know about through the [AssetManager.getJavaScriptFiles](#) event.

#### Reloading the report

In your **plugin.js** file, add the following code in the `$(document).ready` callback:

    // Piwik loads most content via AJAX, so we use $.on instead of $.click directly
    $('body').on('click', '#realtime-reports-reload', function (e) {
        e.preventDefault();

        var $dataTableRoot = $('div.dataTable[data-report="MyPlugin.getLastVisitsByBrowser"]');

        // in the UI, the root element of a displayed report has a JavaScript object associated with it.
        // we can use this object to reload the report.
        var dataTableInstance = $dataTableRoot.data('uiControlObject');

        // we want the table to be completely reset, so we'll reset some query parameters then reload
        // the report
        dataTableInstance.resetAllFilters();
        dataTableInstance.reloadAjaxDataTable();

        return false;
    });

If you click on the new **Reload** link, you'll see the report being reloaded.

Well, our simple plugin is done! It defines a new report, displays it and makes sure the data it displays is fresh. But we can do better! [The next guide](/guides/getting-started-part-3) will show you how.

<div markdown="1" class="alert alert-warning">
**If you believe you're ready to start developing your plugin,** please take the time to read our security guide [Security in Piwik](#). We have very high security standards that your plugin or contribution **must** respect.
</div>